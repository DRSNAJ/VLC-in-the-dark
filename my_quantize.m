function bitsOut = my_quantize(sig, spb, P_guard, N)
%This function us used to quantize the electical signal to allow for
%demodulation for a optisystems simulation
%
% INPUTS---
%   sig:        electrical signal
%
%   spb:        samples per bit
%
%   P_guard:    the percentage of the samples per bit to be extracted
%               this is done to make sure we do not sample at the edges of 
%               the pulses leading to bit errors
%
%   N_noise:    number of bits used to hold the noise sample
%
% OUTPUTS---
%   bits:       the number of quantized bits
%

smpl_w = ones(1,spb);

zw = round(spb*P_guard/4)*2; % number of zeros to be introduced on each side MUST BE EVEN 
z_idx = mod((spb-zw:spb+zw)-1,spb) + 1 ;

smpl_w(z_idx) = 0;
seq_L = length(sig);
smpl = ~(repmat(smpl_w,1,seq_L/spb)>0);

%% Noise floor
N_noise = floor(N/2)-1;
noise_smpl = sig(1:spb*(N_noise)); % here we are taking the first half of a symbol
% noise_smpl = noise_smpl(noise_smpl>min(noise_smpl)*0.5);
noise_smpl = noise_smpl(noise_smpl>2); % this line of code is used to filter out any static noise generated by equipment and therefore,
% it needs to be changed based on equipment used
noise_flr = mean(noise_smpl)*8/5; % setting the 80th percentile as the noise floor for the signal

if isnan(noise_flr)
    noise_flr = 1;
end

%% Extracting Binary Values from pulses 
rx_f = smpl.*sig; % removing the P_guard bits
rx_f = rx_f(spb/2:seq_L-(spb/2+1)); % this is an artifcat of simulation 
rx_f(rx_f<noise_flr) = 0;

% [f,b] = hist(sig,10);
thresh = P_guard*spb*noise_flr;

bitsOut = double(sum(reshape(rx_f,spb,[])',2)>thresh)';
end

